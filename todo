NEXT:
- Make sure root set doesn't get processed twice

Other:
- Implement tail call elimination
- Variables + tail calls can implement for-loops
- Implement objects
  - Instantiation - how can I write these productions?  What's the lhs?
  - Field get/set
  - Array element get/set
    - How do arrays differ from normal objects?  Just tag :ARRAY?
- Play around with things like :PRODUCTION and :TOKEN_BLOCK as first-class values
- Create a token stream out of objects and solve a problem by parsing it
- Tighten up semantics:
  - Lexical scope vs dynamic scope?
  - Parse every piece of program code just once if possible
- Take command line args and file IO
  - System calls in general?  Native methods?
- Expose associativity in the language
- Can we get rid of the curly braces?
- Two reduces with the same action (and possibly same RHS?) should not conflict.
    Not sure how to do that because Grammar doesn't know the actions.
- Figure out what I'm doing with if statements in the brave new world where "return" is unnecessary
- Wiki syntax thing


Ideas
- Maybe "def" can stay the way it is, and can modify grammars incrementally.
  Modules can have a syntax senction that declares new productions and an
  implementation that provides bodies.  This is still very single-pass-ish but
  I don't see what else I can do if I can't even know to parse a section of
  text looking for the productions used to parse it!
